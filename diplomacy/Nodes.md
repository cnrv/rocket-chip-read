[Rocket](../Readme.md)/[diplomacy](../diplomacy.md)/[Node](https://github.com/freechipsproject/rocket-chip/blob/master/src/main/scala/diplomacy/Nodes.scala)
=====================
*The base classes of nodes on on-chip interconnects.*

**********************

trait InwardNodeImp
-------------------------------
*Typeclass for nodes with input channels.*

~~~scala
trait InwardNodeImp[DI, UI, EI, BI <: Data]
~~~

+ **DI** Downwards flowing Parameters received on the inner side of the node
+ **UI** Upwards flowing Parameters generated by the inner side of the node
+ **EI** Packet parameters (generators) for this node.
+ **BI** Bundle type
<br><br>
+ **edgeI** `(pd: DI, pu: UI) => EI`<br>
    Get the parameters for an input channel.
+ **bundleI** `(ei: EI) => BI`<br>
    Generate the input channel.
+ **colour** `_ => String`<br>
    Get the color in node connection graph.
+ **connect** `(bindings: () => Seq[(EI, BI, BI)]) => (monitor:Option[LazyModule], bind:() => Unit)`<br>
    The callback for the actually binding operation.<br>
    _bindings_: (packet parameter, input channel, output channel), the pairs of channels to be connected.<br>
    _monitor_: The optional monitor node to be connected.<br>
    _bind_: The actual connection procedure to be called later by LazyModule.

trait OutwardNodeImp
------------------------------
*Typeclass for nodes with output channels.*

~~~scala
trait OutwardNodeImp[DO, UO, EO, BO <: Data]
~~~

+ **DO** Downwards flowing Parameters generated by the outer side of the node
+ **UO** Upwards   flowing Parameters received on the outer side of the node
+ **EO** Edge Parameters describing a connection on the outer side of the node
+ **BO** Bundle type used when connecting to the outer side of the node
<br><br>
+ **edgeO** `(pd: DO, pu: UO) => EO`<br>
    Get the parameters for an output channel.
+ **bundleO** `(eo: EO) => BO`<br>
    Generate the output channel.

abstract class NodeImp
--------------------------------
*Abstract root of nodes*

~~~scala
abstract class NodeImp[D, U, EO, EI, B <: Data]
  extends Object with InwardNodeImp[D, U, EI, B] with OutwardNodeImp[D, U, EO, B]
~~~

~~~diff
- Why differ EO and EI but not B?
~~~

abstract class BaseNode
---------------------------
*Base class of all Node parameter*

+ **lazyModule** `LazyModule` pointer to the lazyModule
+ **index** `Int` index of the node in this lazyModule (think about the index of a port in a crossbar)
+ **externalIn** `Boolean` ??
+ **externalOut** `Boolean` ??
+ **nodename** `() => String` node name
+ **name** `() => String` hierarchical node name
+ **omitGraphML** `() => Bool` a portless node does not need a connection graph
+ **gci** `() => Option[BaseNode]` get the greatest common inner node type
+ **gco** `() => Option[BaseNode]` get the greatest common outer node type
+ **outputs** `() => Seq[(BaseNode, String)]` list of outer nodes
+ **inputs** `() => Seq[(BaseNode, String)]` list of inner nodes
+ **colour** `() => String` node color



case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
---------------------------

~~~scala
case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
    (inward: InwardNode[DI, UI, BI], outward: OutwardNode[DO, UO, BO])
    extends Object with InwardNodeHandle[DI, UI, BI] with OutwardNodeHandle[DO, UO, BO]
~~~

case object BIND\_ONCE
---------------------------------
*Normal one to one connection*

case object BIND\_QUERY
---------------------------------
*A shared sink port?*

case object BIND\_STAR
---------------------------------
*A shared source port?*


trait InwardNodeHandle[DI, UI, BI <: Data]
---------------------------

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ **:=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`

    Connect this input port to an output port `h`.

+ **&ast;=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`

    Connect this input multi-port to an output `h`??

+ **=&ast;** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`

    Connect this input port to an output multi-port `h`??


trait InwardNode[DI, UI, BI <: Data]
------------------------
    trait InwardNode[DI, UI, BI <: Data] extends BaseNode with InwardNodeHandle[DI, UI, BI]

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ *numPI: Range.Inclusive*: number of inner nodes (numPI >= 0)
+ *iPushed: _ => Int*: number of inner nodes being processed
+ *iPush: (node:Int, node: OutwardNode[DI, UI, BI], binding: NodeBinding) => Unit*: process an inner node
+ *iBindings: List[(Int, OutwardNode[DI, UI, BI], NodeBinding)]*: list of inner nodes (index, input, binding)
+ *iStar: Int*: ??
+ *iPortMapping: Seq[(Int, Int)]*: range of each inner nodes
+ *iParams: Seq[UI]*: inner node parameters
+ *bundleIn: Vec[BI]*: inner node bundles

trait OutwardNodeHandle[DO, UO, BO <: Data]
---------------------------

+ *outward: OutwardNode[DO, UO, BO]*: self object pointer


trait OutwardNode[DO, UO, BO <: Data]
----------------------------
    trait OutwardNode[DO, UO, BO <: Data] extends BaseNode with OutwardNodeHandle[DO, UO, BO]

+ *outward: OutwardNode[DO, UO, BO]*: self object pointer
+ *numPO: Range.Inclusive*: number of putputs (numPO >= 0)
+ *oPushed: _ => Int*: number of outer nodes being processed
+ *oPush: (index: Int, node: InwardNode [DO, UO, BO], binding: NodeBinding) => Unit*: process an outer node
+ *oBindings: List[(Int, InwardNode [DO, UO, BO], NodeBinding)]*: list of outer nodes (index, output, binding)
+ *oStar: Int*: ??
+ *oPortMapping: Seq[(Int, Int)]*: Range of each outer nodes
+ *oParams: Seq[DO]*: outer node parameters
+ *bundleOut: vec[BO]*: outer node bundles


abstract class MixedNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data]
---------------------------
~~~scala
abstract class MixedNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
    inner: InwardNodeImp [DI, UI, EI, BI],
    outer: OutwardNodeImp[DO, UO, EO, BO])(
    protected[diplomacy] val numPO: Range.Inclusive,
    protected[diplomacy] val numPI: Range.Inclusive)
    extends BaseNode with InwardNode[DI, UI, BI] with OutwardNode[DO, UO, BO]
~~~

+ *oPorts: (Int, (Int, InwardNode [DO, UO, BO]))*: mapping from outer node to inner nodes?
+ *iPorts: (Int, (Int, OutwardNode [DO, UO, BO]))*: mapping from inner node to outer nodes?

class MixedAdapterNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data]
-----------

~~~scala
class MixedAdapterNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
  inner: InwardNodeImp [DI, UI, EI, BI],
  outer: OutwardNodeImp[DO, UO, EO, BO])(
  dFn: DI => DO,
  uFn: UO => UI,
  num: Range.Inclusive = 0 to 999)
  extends MixedNode(inner, outer)(num, num)
~~~

class AdapterNode[D, U, EO, EI, B <: Data]
-----------
*Base node class for a bus adapter.*

~~~scala
class AdapterNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(
  dFn: D => D,
  uFn: U => U,
  num: Range.Inclusive = 0 to 999)
    extends MixedAdapterNode[D, U, EI, B, D, U, EO, B](imp, imp)(dFn, uFn, num)
~~~

class NexusNode[D, U, EO, EI, B <: Data]
-----------
*Base node for a switch node (crossbar, multiplexer ordemultiplexer).*

~~~scala
class NexusNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(
  dFn: Seq[D] => D,
  uFn: Seq[U] => U,
  numPO: Range.Inclusive = 1 to 999,
  numPI: Range.Inclusive = 1 to 999)
    extends MixedNexusNode[D, U, EI, B, D, U, EO, B](imp, imp)(dFn, uFn, numPO, numPI)
~~~

class IdentityNode[D, U, EO, EI, B <: Data]
-----------

~~~scala
class IdentityNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
  extends AdapterNode(imp)({s => s}, {s => s})
~~~

class OutputNode[D, U, EO, EI, B <: Data]
-------------

~~~scala
class OutputNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
    extends IdentityNode(imp)
~~~

class InputNode[D, U, EO, EI, B <: Data]
----------

~~~scala
class InputNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
    extends IdentityNode(imp)
~~~

class SourceNode[D, U, EO, EI, B <: Data]
------------

~~~scala
class SourceNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(po: Seq[D])
  extends MixedNode(imp, imp)(po.size to po.size, 0 to 0)
~~~

class SinkNode[D, U, EO, EI, B <: Data]
-----------

~~~scala
class SinkNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(pi: Seq[U])
  extends MixedNode(imp, imp)(0 to 0, pi.size to pi.size)
~~~



<br><br><br><p align="right"><sub>[CC-BY](https://creativecommons.org/licenses/by/3.0/), &copy; (2017) [Wei Song](mailto:wsong83@gmail.com), 21/04/2017</sub></p>
