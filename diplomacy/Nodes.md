[Rocket](../Readme.md)/[diplomacy](../diplomacy.md)/[Node](https://github.com/ucb-bar/rocket-chip/blob/master/src/main/scala/diplomacy/Nodes.scala)
=====================

**********************

trait InwardNodeImp[DI, UI, EI, BI <: Data]
-------------------------------
*Typeclass for nodes with input channels.*

### Type variables:

+ **DI** Downwards flowing Parameters received on the inner side of the node
+ **UI** Upwards flowing Parameters generated by the inner side of the node
+ **EI** Edge Parameters describing a connection on the inner side of the node
+ **BI** Bundle type used when connecting to the inner side of the node

### Member variables and functions:

+ **edgeI** `(pd: DI, pu: UI) => EI`

    Get the parameters for an input channel.

+ **bundleI** `(ei: EI) => BI`

    Generate the input channel.

+ **colour** `_ => String`

    Get the color in node connection graph.

+ **connect** `(bindings: () => Seq[(EI, BI, BI)]) => (Option[LazyModule], () => Unit)`

    The callback for the actually binding operation.
    For the return value, `Option[LazyModule]` is used to define a bus monitor?
    `() => Unit` is the port connection callback which is processed after LazyModules emit Modules.

trait OutwardNodeImp[DO, UO, EO, BO <: Data]
------------------------------
*Typeclass for nodes with output channels.*

### Type variables:

+ **DO** Downwards flowing Parameters generated by the outer side of the node
+ **UO** Upwards   flowing Parameters received on the outer side of the node
+ **EO** Edge Parameters describing a connection on the outer side of the node
+ **BO** Bundle type used when connecting to the outer side of the node

### Member variables and functions:

+ **edgeO** `(pd: DO, pu: UO) => EO`

    Get the parameters for an output channel.

+ **bundleO** `(eo: EO) => BO`

    Generate the output channel.

abstract class NodeImp[D, U, EO, EI, B <: Data]
--------------------------------
    abstract class NodeImp[D, U, EO, EI, B <: Data]
      extends Object with InwardNodeImp[D, U, EI, B] with OutwardNodeImp[D, U, EO, B]

abstract class BaseNode
---------------------------
*Base class of all Node classes*

+ *lazyModule: LazyModule*: ??
+ *index: Int*: ??
+ *externalIn: Boolean*: ??
+ *externalOut: Boolean*: ??
+ *nodename: _ => String*: get node name
+ *name: _ => String*: get hierarchical node name ??
+ *omitGraphML: _ => Bool*: omit graph generation when no inner or no outer nodes
+ *gci: _ => Option[BaseNode]*: get the greatest common inner node type
+ *gco: _ => Option[BaseNode]*: get the greatest common outer node type
+ *outputs: _ => Seq[(BaseNode, String)]*: list of outer nodes
+ *inputs: _ => Seq[(BaseNode, String)]*: list of inner nodes
+ *colour: _ => String*: node color



case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
---------------------------

~~~scala
case class NodeHandle[DI, UI, BI <: Data, DO, UO, BO <: Data]
    (inward: InwardNode[DI, UI, BI], outward: OutwardNode[DO, UO, BO])
    extends Object with InwardNodeHandle[DI, UI, BI] with OutwardNodeHandle[DO, UO, BO]
~~~

case object BIND\_ONCE
---------------------------------
*Normal one to one connection*

case object BIND\_QUERY
---------------------------------
*A shared sink port?*

case object BIND\_STAR
---------------------------------
*A shared source port?*


trait InwardNodeHandle[DI, UI, BI <: Data]
---------------------------

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ **:=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`

    Connect this input port to an output port `h`.

+ **&ast;=** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`

    Connect this input multi-port to an output `h`??

+ **=&ast;** `(h: OutwardNodeHandle[DI, UI, BI]) => Option[LazyModule]`

    Connect this input port to an output multi-port `h`??


trait InwardNode[DI, UI, BI <: Data]
------------------------
    trait InwardNode[DI, UI, BI <: Data] extends BaseNode with InwardNodeHandle[DI, UI, BI]

+ *inward: InwardNode[DI, UI, BI]*: self object pointer
+ *numPI: Range.Inclusive*: number of inner nodes (numPI >= 0)
+ *iPushed: _ => Int*: number of inner nodes being processed
+ *iPush: (node:Int, node: OutwardNode[DI, UI, BI], binding: NodeBinding) => Unit*: process an inner node
+ *iBindings: List[(Int, OutwardNode[DI, UI, BI], NodeBinding)]*: list of inner nodes (index, input, binding)
+ *iStar: Int*: ??
+ *iPortMapping: Seq[(Int, Int)]*: range of each inner nodes
+ *iParams: Seq[UI]*: inner node parameters
+ *bundleIn: Vec[BI]*: inner node bundles

trait OutwardNodeHandle[DO, UO, BO <: Data]
---------------------------

+ *outward: OutwardNode[DO, UO, BO]*: self object pointer


trait OutwardNode[DO, UO, BO <: Data]
----------------------------
    trait OutwardNode[DO, UO, BO <: Data] extends BaseNode with OutwardNodeHandle[DO, UO, BO]

+ *outward: OutwardNode[DO, UO, BO]*: self object pointer
+ *numPO: Range.Inclusive*: number of putputs (numPO >= 0)
+ *oPushed: _ => Int*: number of outer nodes being processed
+ *oPush: (index: Int, node: InwardNode [DO, UO, BO], binding: NodeBinding) => Unit*: process an outer node
+ *oBindings: List[(Int, InwardNode [DO, UO, BO], NodeBinding)]*: list of outer nodes (index, output, binding)
+ *oStar: Int*: ??
+ *oPortMapping: Seq[(Int, Int)]*: Range of each outer nodes
+ *oParams: Seq[DO]*: outer node parameters
+ *bundleOut: vec[BO]*: outer node bundles


abstract class MixedNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data]
---------------------------
~~~scala
abstract class MixedNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
    inner: InwardNodeImp [DI, UI, EI, BI],
    outer: OutwardNodeImp[DO, UO, EO, BO])(
    protected[diplomacy] val numPO: Range.Inclusive,
    protected[diplomacy] val numPI: Range.Inclusive)
    extends BaseNode with InwardNode[DI, UI, BI] with OutwardNode[DO, UO, BO]
~~~

+ *oPorts: (Int, (Int, InwardNode [DO, UO, BO]))*: mapping from outer node to inner nodes?
+ *iPorts: (Int, (Int, OutwardNode [DO, UO, BO]))*: mapping from inner node to outer nodes?

class MixedAdapterNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data]
-----------

~~~scala
class MixedAdapterNode[DI, UI, EI, BI <: Data, DO, UO, EO, BO <: Data](
  inner: InwardNodeImp [DI, UI, EI, BI],
  outer: OutwardNodeImp[DO, UO, EO, BO])(
  dFn: DI => DO,
  uFn: UO => UI,
  num: Range.Inclusive = 0 to 999)
  extends MixedNode(inner, outer)(num, num)
~~~

class AdapterNode[D, U, EO, EI, B <: Data]
-----------
*Base node class for a bus adapter.*

~~~scala
class AdapterNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(
  dFn: D => D,
  uFn: U => U,
  num: Range.Inclusive = 0 to 999)
    extends MixedAdapterNode[D, U, EI, B, D, U, EO, B](imp, imp)(dFn, uFn, num)
~~~

class NexusNode[D, U, EO, EI, B <: Data]
-----------
*Base node for a switch node (crossbar, multiplexer ordemultiplexer).*

~~~scala
class NexusNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(
  dFn: Seq[D] => D,
  uFn: Seq[U] => U,
  numPO: Range.Inclusive = 1 to 999,
  numPI: Range.Inclusive = 1 to 999)
    extends MixedNexusNode[D, U, EI, B, D, U, EO, B](imp, imp)(dFn, uFn, numPO, numPI)
~~~

class IdentityNode[D, U, EO, EI, B <: Data]
-----------

~~~scala
class IdentityNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
  extends AdapterNode(imp)({s => s}, {s => s})
~~~

class OutputNode[D, U, EO, EI, B <: Data]
-------------

~~~scala
class OutputNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
    extends IdentityNode(imp)
~~~

class InputNode[D, U, EO, EI, B <: Data]
----------

~~~scala
class InputNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])
    extends IdentityNode(imp)
~~~

class SourceNode[D, U, EO, EI, B <: Data]
------------

~~~scala
class SourceNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(po: Seq[D])
  extends MixedNode(imp, imp)(po.size to po.size, 0 to 0)
~~~

class SinkNode[D, U, EO, EI, B <: Data]
-----------

~~~scala
class SinkNode[D, U, EO, EI, B <: Data](imp: NodeImp[D, U, EO, EI, B])(pi: Seq[U])
  extends MixedNode(imp, imp)(0 to 0, pi.size to pi.size)
~~~

**********************

```scala
last modified = 28/03/2017
authors       = Wei Song <wsong83@gmail.com>
license       = CC-BY <https://creativecommons.org/licenses/by/3.0/>
```
